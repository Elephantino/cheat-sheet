<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>js</title>
  <link rel="stylesheet" href="../style.css">
</head>

<body>
  <div class="wrapper">



    <header class="page--header">
      <div class="container">
        <div class="header__inner">

          <a href="../index.html">
            <!-- <svg width="125px" height="20px">
              <use href="../img/sprite.svg#logo"></use>
            </svg> -->
            <img src="../img/logo.png" alt="">
          </a>

          <ul class="header-list list-reset">
            <li class="item"><a href="examples.html">examples</a></li>
            <li class="item"><a href="html.html">html</a></li>
            <li class="item"><a href="css.html">css</a></li>
            <li class="item"><a href="js.html">js</a></li>
            <li class="item"><a href="svg.html">svg</a></li>
            <li class="item"><a href="about.html">about</a></li>
          </ul>

        </div>
      </div>
    </header>




    <main class="main">
      <div class="container">
        <div class="main__inner">

          <section class=" layout">

            <div class="menu-on-page">
              <button class="menu-on-page__btn"></button>
              <ol class="layout__tab-list list-reset">

                <li class="layout__tab-item"><a href="#проверки">проверки</a></li>
                <li class="layout__tab-item"><a href="#Преобразования">Преобразования</a></li>
                <li class="layout__tab-item"><a href="#Изменение документа">Изменение документа</a></li>
                <li class="layout__tab-item"><a href="#Стили и классы">Стили и классы</a></li>
                <li class="layout__tab-item"><a href="#export-import">export-import</a></li>
                <li class="layout__tab-item"><a href="#структуры">структуры</a></li>
                <li class="layout__tab-item"><a href="#Логические операторы">Логические операторы</a></li>
                <li class="layout__tab-item"><a href="#циклы">циклы</a></li>
                <li class="layout__tab-item"><a href="#Получение элементов">Получение элементов</a></li>
                <li class="layout__tab-item"><a href="#events">events</a></li>
                <li class="layout__tab-item"><a href="#"></a></li>
                <li class="layout__tab-item"><a href="#"></a></li>
                <li class="layout__tab-item"><a href="#"></a></li>
                <li class="layout__tab-item"><a href="#"></a></li>
                <li class="layout__tab-item"><a href="#"></a></li>

              </ol>
            </div>



            <section class="transformation-document"><!-- Изменение документа -->

              <a name="Изменение документа">
                <h2>Изменение документа</h2>
              </a>

              <section class="createElement">

                <h3>Создание элемента</h3>
                <textarea cols="52" rows="16">
let elem = document.createElement("button")
  elem.textContent = "Click-me"
  elem.title = "button"
  elem.className = "btn"
  elem.style.cssText += ` color: ...; font-size: ... `
  elem.style.colot = "red"
  
  elem.onmouseover = function() {
    this.style.color = "red"
  }
  elem.onmouseout = function() {
    this.style.color = "black"
  }
  
document.body.appendChild(elem);
</textarea>

                <textarea cols="52" rows="7">
document.createTextNode('value') - схож с textContent

let div = document.createElement("div");
let text = document.createTextNode("новый текст")

div.appendChild(text);
</textarea>

                <details class="show-piece">
                  <summary><code>на основе шаблонной строки</code></summary>
                  <textarea cols="85" rows="25">

const createElFromStr = (str) => { 
	const el = document.createElement("div") (1)создаем временный элемент
	el.innerHTML = str  (2)записываем в него строку
	const child = el.firstElementChild  (3)извлекаем наш элемент 
	el.remove() (4)удалим временный элемент
	return child (5)возвращаем элемент
}

const listTemplate = `  шаблон списка
<ul id="list">
  <li data-id="item1" class="item">1</li>
  <li data-id="item2" class="item">2</li>
  <li data-id="item3" class="item">3</li>
</ul>
`
  
const listEl = createElFromStr(listTemplate) (6)создаем список на основе шаблона

document.body.appendChild(listEl) (7)вставляем его


(3) если использовать firstChild то вернется #text(пробелы тоже текстовые элементы) по этому нужно вернуть именно элемент а не первого потомка
</textarea>
                </details>


                <details class="show-piece">
                  <summary><code>при помощи конструктора DOMParser()</code></summary>
                  <textarea cols="60" rows="19">
const createElFromStr = (str) => { 
  const parser = new DOMParser() (1)создаем новый парсер
  const {  (2)парсер вернет новый документ
    body: { children }   
  } = parser.parseFromString(str, "text/html")
  return children[0] (3)первый дочерний элемент нового тела
}

const listTemplate = `  
<ul id="list">
  <li data-id="item1" class="item">1</li>
  <li data-id="item2" class="item">2</li>
  <li data-id="item3" class="item">3</li>
</ul>
`

const listEl = createElFromStr(listTemplate)
document.body.appendChild(listEl)
</textarea>
                </details>


                <details class="show-piece">
                  <summary><code>при помощи расширения для объекта Range</code></summary>
                  <p>методом createContextualFragment()</p>

                  <textarea cols="75" rows="19">
const createFragment = (str) => {
  const range = new Range()
  const fragment = range.createContextualFragment(str)
  return fragment
}
       то же самое но в 1 строку:
	   
const createFragment = (str) => new Range().createContextualFragment(str)

const listTemplate = `  
<ul id="list">
  <li data-id="item1" class="item">1</li>
  <li data-id="item2" class="item">2</li>
  <li data-id="item3" class="item">3</li>
</ul>
`

document.body.appendChild(createFragment(listTemplate))
</textarea>
                </details>


              </section>

              <ul>
                <li><code>document.createTextNode('value') - схож с textContent</code></li>
              </ul>

              <details class="show-piece cloneNode"> <!-- клонирование узлов -->
                <summary><code>cloneNode -- </code>клонирование узлов</summary>
                <ul>
                  <li><code>deep - </code>true</li>
                  <li><code>elem.cloneNode(true) - </code>со всеми атрибутами и дочерними элементами.</li>
                  <li><code>elem.cloneNode(false) - </clone> без дочерних элементов.</li>
</ul>
    
<textarea  cols="50" rows="8">
<div id="div">
  Всем привет!
</div>

let clone = div.cloneNode(true); // клонировать
clone.innerHTML = 'Всем пока!'; // изменить
document.body.insertBefore(clone, div); // вставить
</textarea>

</details>


<details class="show-piece remove">
        <summary><code>parent.removeChild(node)</code></summary>
                    <p>родитель.removeChild(дочерний элемент)</p>
                    <p>вызываем метод на родительском элементе(parentNode) и передаем аргументом дочерний элемент
                      который нужно удалить</p>
                    <textarea cols="65" rows="16">
<ul class="ul">
  <li>1</li>
  <li>2</li>
  <li>3</li>
</ul>


let liSecond = document.querySelector(".ul li:nth-child(2);
liSecond.parentNode.removeChild(liSecond);


<ul class="ul">
  <li>1</li>
  <li>2</li>
</ul>
</textarea>

                    <p>удаленный элемент можно вставить потому что removeChild возвращает удаленный элемент</p>


                    <textarea cols="30" rows="10">

let p;
let div; 

let result = p.parentElement.removeChild(p); удалим со старого места

div.appendChild(result); вставим в новое место
</textarea>

              </details>



              <details class="show-piece remove">
                <summary><code>node.remove(); -- удаление узлов</code></summary>
                <textarea cols="75" rows="10">
            элемент появится и исчезнет через секунду

let div = document.createElement('div');
div.className = "alert";
div.innerHTML = "<strong>Всем привет!</strong> Вы прочитали важное сообщение.";

document.body.append(div);
setTimeout(() => div.remove(), 1000);
</textarea>

                <textarea cols="30" rows="10">
  удалим кнопку по нажатию

<button>btn</button>

button.onclick = function() {
  this.remove();
}

</textarea>
              </details>


              <section class="getting-elements"><!-- Получение элементов -->
                <details class="show-block">
                  <summary><code><a name="Получение элементов">
                Получение элементов
              </a></code></summary>

                  <p> Почти все методы возвращают коллекции элементов схожих с массивом
                    но это объекты классов: Array, NodeList, HTMLCollection и т.д.
                    к которым нужно обращаться по индексу <span class="color-yellow">arr.[0]/[1]/[2]</span></p>


                  <pre>
  <code>
<span class="color-red-light">element</span>        
   
let e = document.<span class="color-blue">querySelector</span>('#nav &gt; ul.menu__list &gt; li[name="li"] + li');
console.log(e); <span class="color-yellow">// element</span>
   
let eId = document.<span class="color-red-light">getElementById</span>('menu__item-3');
console.log(eId);  <span class="color-yellow">// element</span>
   
   
<span class="color-red-light">NodeList</span> - статическая коллекция элементов  

document.querySelectorAll("#source-list li:nth-child(even)"); // все четные li

let eAll = document.<span class="color-blue">querySelectorAll</span>('li');
console.log(eAll); <span class="color-yellow">// NodeList</span>
console.log(eAll<span class="color-yellow">[0]</span>); <span class="color-yellow">// element</span>
   
let eName = document.<span class="color-red-light">getElementsByName</span>('li'); //динамическая коллекция 
console.log(eName); <span class="color-yellow">// NodeList</span>
console.log(eName<span class="color-yellow">[1]</span>);<span class="color-yellow">// element</span> 
   
let e = list.<span class="color-blue-light">childNodes</span>; //динамическая коллекция
  хранит в себе псевдомассив дочерних узлов 
  элемента (теги, комментарии и текстовые узлы).
   
   
<span class="color-red-light">HTMLCollection</span> - динамическая коллекция элементов
                        
let eTag = document.<span class="color-red-light">getElementsByTagName</span>('li');
console.log(eTag);   <span class="color-yellow">// HTMLCollection</span>
console.log(eTag<span class="color-yellow">[2]</span>);  <span class="color-yellow">// element</span> 
   
let eClass = document.<span class="color-red-light">getElementsByClassName</span>('menu__item');
console.log(eClass); <span class="color-yellow">// HTMLCollection</span>  
console.log(eClass<span class="color-yellow">[3]</span>);   <span class="color-yellow"> // element </span> 
      </code>
   </pre>

                </details>
              </section>


              <section><!-- вставить элемент -->

                <details class="show-block">
                  <summary><code>вставить элемент</code></summary>


                  <p>методы ниже заменят теги на текст</p>
                  <p class="color-red">
                    <code>Все методы вставки автоматически удаляют узлы со старых мест(кроме клонирования).</code>
                  </p>

                  <details class="show-piece"> <!-- prepend, append, before, after -->
                    <summary><code>prepend, append, before, after -- </code>заменяют теги на текст</summary>

                    <textarea cols="55" rows="27">
<div id="test">test</div>

let prepend = document.createElement("p");
let append = document.createElement("p");
let before = document.createElement("p");
let after = document.createElement("p");

prepend.innerHTML = "prepend";
append.innerHTML = "append";
before.innerHTML = "before";
after.innerHTML = "after";

test.prepend(prepend);
test.append(append);
test.before(before);
test.after(after);

    output:
    
             before
          ┌───────────┐&lt;--<div id="test">test</div>
          │  prepend  │
          │   test    │
          │  append   │
          └───────────┘
             after
</textarea>

                    <p class="color-red">если эти методы использовать для вставки элементов то теги заменятся на текст
                    </p>

                    <textarea cols="60" rows="20">
<div id="div"></div>

div.prepend(
  '<p>можно вставить несколько элементов за раз</p>',
  "<div>но теги будут заменяться на текст</div>",
        
  document.createElement('hr'), 
        
  "<p>теги станут как обычный текст</p>",
);

output 

<p>можно вставить несколько элементов за раз</p>
<div>но теги будут заменяться на текст</div>
        
<hr>
        
<p>теги станут как обычный текст</p>	
</textarea>





                  </details>



                  <details class="show-piece"> <!-- replaceChild -->
                    <summary><code>replaceChild - </code>заменить элемент другим</summary>
                    <p>parentNode.replaceChild(newChild, oldChild)</p>

                    <ul>
                      <li>newChild - новый элемент который заменит oldChild</li>
                      <li>psrentNode - родитель odChild</li>
                    </ul>
                    <p>parentNode в результате вернет oldChild</p>

                    <textarea cols="30" rows="10">
	заменим li
	
<ul class="ul">
  <li>1</li>
  <li>2</li>
  <li>3</li>
</ul>

let oldLi = document.querySelector(".ul li:nth-child(2)");
let newLi = document.createElement("li");
newLi.textContent = "Five";
oldLi.parentNode.replaceChild(newLi, oldLi);

элемент.родитель.replaceChild(новый элемент, старый элемент)
</textarea>



                  </details>



                  <details class="show-piece"> <!-- replaceWith -->
                    <summary><code>node.replaceWith - </code>заменить node узлом или строкой</summary>
                    <p>parentNode.replaceWith(...nodes, string)</p>

                    <textarea cols="30" rows="10">
<ul class="ul">
  <li>1</li>
  <li>2</li>
  <li>3</li>
</ul>

let oldLi = document.querySelector(".ul li:nth-child(2)");
let newLi1 = document.createElement("li");
let newLi2 = document.createElement("li");
newLi1.textContent = "newLi1";
newLi2.textContent = "newLi2";

oldLi.replaceWith(newLi1, newLi2);

<ul class="ul">
  <li>1</li>
  <li>2</li>
  <li>newLi1</li>
  <li>newLi2</li>
</ul>
</textarea>
                  </details>















                  <div class="performance"><!-- Устаревшие методы -->

                    <h3>Устаревшие методы</h3>
                    <details class="show-piece">
                      <summary><code>elem.appendChild(node); - </code>вставит node после последнего элемента внутри elem
                      </summary>

                      <pre><code>
let div = document.querySelector(".div");
let p = document.createElement("p");

div.appendChild(p);

</code></pre>
                    </details>


                    <details class="show-piece">
                      <summary><code>elem.insertBefore(node, nextSibling) - </code>вставит узел node перед nextSibling
                        внутри elem</summary>
                      <pre><code>
let elem = document.querySelector(".insertBefore");
let li = document.createElement("li");
li.textContent = "new li";

elem.insertBefore(li, elem.children[3]); //вставит перед 4

1
2
3
new li
4


если передать null то он будет работать как .appendChild

elem.insertBefore(li, null); 

1
2
3
4
new li

</code></pre>
                    </details>


                  </div>



                  <h3 class="color-red">но что делать если нужно вставить элемент а не текст? --
                    <code>insertAdjacentHTML</code>
                  </h3>

                  <details class="show-piece insertAdjacentHTML">
                    <summary><code>insertAdjacentHTML(where, elem или text) -- </code>вставить фрагмент html или текст
                    </summary>


                    <div class="show-code">
                      <h2 class="show-code__title"></h2>
                      <div class="show-code__description">
                      </div>
                      <div class="show-code__inner">
                        <div class="show-code__performance">
                          <section class="insertAdjacentHTML">
                            <div class="output">
                              <p>beforebegin</p>
                              <div class="test">
                                <p>afterbegin</p>
                                <p>test</p>
                                <p>beforeend</p>
                              </div>
                              <p>afterend</p>
                            </div>
                          </section>
                        </div>
                        <textarea class="show-code__textarea">
<div id="test">test</div>

test.insertAdjacentHTML("beforebegin", "<p>beforebegin</p>");
test.insertAdjacentHTML("afterbegin", "<div>afterbegin</div>");
test.insertAdjacentHTML("beforeend", "<section>beforeend</section>");
test.insertAdjacentHTML("afterend", "<a>afterend</a>");
    </textarea>
                      </div>
                    </div>

                    <textarea cols="65" rows="14">
let details = document.createElement('details'); // создаем элемент
elem.append(details); // добавляем элемент на страницу

//фаршируем внутри наш элемент
details.insertAdjacentHTML('afterbegin', `
<summary><code>...</code></summary>
<p>...</p>
<div>
  <p>...</p>
  <p>...</p>
  <p>...</p>
</div>
`);
</textarea>

                  </details>


                  <details class="show-piece DocumentFragment">
                    <summary><code>DocumentFragment -- </code>вставить множество элементов</summary>
                    <p>обёртка для временного хранения html элементов</p>
                    <p>это облегченная версия document</p>
                    <p>когда мы его вставляем, вставляется только содержимое</p>



                    <details class="show-piece">
                      <summary><code>пример</code></summary>

                      <textarea cols="30" rows="10">
<ul id="source-list">
  <li>1</li>
  <li>2</li>
  <li>3</li>
  <li>4</li>
  <li>5</li>
</ul>


const sourceLi = document.querySelectorAll("#source-list li:nth-child(even)"); //все четные li
const targetList = document.createElement("ul"); //создаем новый список
const fragment = new DocumentFragment(); //создаем фрагмент

const btn = document.querySelector(".btn") 


btn.onclick = function() { 
	
  for (let i = 0; i &lt; sourceLi.length; i++) {
	fragment.appendChild(sourceLi[i]);
  }

  targetList.appendChild(fragment);
  document.body.appendChild(targetList)
}


по клику на btn список разделится на два вытаща 
все even(четные) из списка запихав их в новый ul с помощью фрагмента
<ul id="source-list">
  <li>1</li>
  <li>3</li>
  <li>5</li>
</ul>

<ul>
  <li>2</li>
  <li>4</li>
</ul>

</textarea>

                    </details>


                    <details class="show-piece">
                      <summary><code>пример</code></summary>


                      <textarea cols="85" rows="21">
        getListContent ниже генерирует фрагмент с элементами &lt;li&gt;, которые позже 
        вставляются в &lt;ul>:
        
&lt;ul id="ul">&lt;/ul>


function getListContent() {
  let fragment = new DocumentFragment();

  for(let i=1; i&lt;=3; i++) {
    let li = document.createElement('li');
    li.append(i);
    fragment.append(li);
  }

  return fragment;
}

ul.append(getListContent()); // (*)

</textarea>

                      <p>Обратите внимание, что на последней строке с (*) мы добавляем DocumentFragment, но он
                        «исчезает», поэтому структура будет:</p>

                      <textarea cols="12" rows="6">
&lt;ul>
  <li>1</li>
  <li>2</li>
  <li>3</li>
&lt;/ul>
</textarea>

                    </details>

                    <p>DocumentFragment редко используется. Зачем добавлять элементы в специальный вид узла, если вместо
                      этого мы можем вернуть массив узлов? </p>
                    <p></p>

                    <textarea cols="70" rows="20">
&lt;ul id="ul">&lt;/ul>

&lt;script>
function getListContent() {
  let result = [];

  for(let i=1; i&lt;=3; i++) {
    let li = document.createElement('li');
    li.append(i);
    result.push(li);
  }

  return result;
}

ul.append(...getListContent()); // append + spread / rest
&lt;/script>
</textarea>


                  </details>

                  <details class="show-piece">
                    <summary>document.write</summary>
                    <p>работает только до загрузки страницы.</p>
                    <p>после того, как страница загружена, он уже непригоден к использованию</p>
                  </details>

                </details>
              </section>



            </section>



            <section class="get-content"><!-- получение контента и его установка -->

              <h2>получение контента и его установка</h2>

              <a href="https://itchief.ru/javascript/textcontent#innerhtml-i-outerhtml">источник</a>
              <p>textContent / innerHTML - получить / добавить просто текст</p>
              <p>эти методы меняют текст в уже существующем элементе</p>
              <p>textContent более предпочтительней потому что не нужно парсить html</p>

              <details class="show-piece textContent">
                <summary><code>textContent -- </code>получить/вписать просто текст (и содержимое его потомков).
                </summary>

                <textarea cols="70" rows="3">
element.textContent = 'не парсит&lt;b&gt;html&lt;/b&gt;';  // не парсит &lt;b&gt;html(вставит теги в html)&lt;/b&gt;
element.innerHTML = 'парсит &lt;b&gt;html&lt;/b&gt;';      // парсит <b>html(станет жирным)</b>
</textarea>

                <textarea cols="50" rows="8">
const elem = document.querySelector(".elem");

//получаем содержимое
const text = elem.textContent; 

//устанавливаем новое содержимое
elem.textContent = "Некоторый текст ..."; 
</textarea>

                <p>Если элемент содержит другие узлы, textContent вернёт конкатенацию текстов всех его текстовых узлов.
                </p>

                <textarea cols="71" rows="18">
<div id="message">
    Внимание!
    <span>Это <strong>очень важный текст.</strong></span>
    <script>alert('важное сообщение!');</script>
</div>
         
<script>
  const $elem = document.querySelector('#message');
  const text = $elem.textContent; 
</script>

output:

  text // "Внимание! Это очень важный текст.alert('важное сообщение!');" 

          textContent -- вернул текстовое содержимое всех потомков
</textarea>

                <p>textContent удалит всего его узлы (при их наличии), и добавит в него один текстовый узел, содержащий
                  указанный текст.</p>


                <textarea cols="110" rows="10">
<div id="message">Внимание! <p>Это <strong>очень важный текст.</strong></p><script>alert('А это очень важное сообщение!');</script></div>

<script>
  const $elem = document.querySelector('#message');

  // эта строчка удалит все элементы в #message и добавит в него текстовый узел с текстом "Новый текст..."
  $elem.textContent = 'Новый текст...';
</script>
</textarea>



                <p>Если присвоить textContent строку, содержащую HTML код, то символы < и> будут заменены.</p>

                <textarea cols="35" rows="3">
$elem.textContent = '<p>...</p>';
const text = $elem.textContent; // "&lt;p&gt;...&lt;/p&gt;"
</textarea>


                <textarea cols="35" rows="11">
    // создадим элемент <div></div>
const $alert = document.createElement('div');
    
    // добавим к $alert класс alert
$alert.className = 'alert';
    
    // установим $alert текстовый контент
$alert.textContent = 'Некоторый текст...';
    
    // вставим на страницу перед </body>
document.body.appendChild($alert);
</textarea>

              </details>


              <details class="show-piece innerHTML">
                <summary><code>innerHTML -- </code>установка или получение текста вместе с HTML разметкой элемента
                </summary>

                <textarea cols="30" rows="3">
const html = $elem.innerHTML;

$elem.innerHTML = '&lt;div>...&lt;div>';
</textarea>

                <p>полностью перезаписывает содержимое элемента</p>

                <textarea cols="40" rows="6">
    полностью очистит содержимое и теги тоже

elem.innerHTML = '';

document.getElementById("demo").innerHTML = "";
</textarea>

                <p>установим внутри ul новый HTML</p>

                <textarea cols="60" rows="4">
const ul = document.querySelector('ul');

ul.innerHTML = `&lt;li>HTML&lt;/li>&lt;li>CSS&lt;/li>&lt;li>JavaScript&lt;/li>`;
</textarea>

                <p>получим HTML разметку некоторого элемента:</p>

                <textarea cols="120" rows="7">
<div class="message">Я люблю <strong>JavaScript</strong>! Он позволяет <span>сделать что угодно со страницей</span>.</div>

<script>
  const $elem = document.querySelector('.message');       // получим HTML элемент .message

  const html = $elem.innerHTML         // получим HTML код $elem
</script>
</textarea>

                <textarea cols="120" rows="8">
            innerHTML полностью перезаписывает содержимое элемента вместе с тегами
        
var myP = document.getElementById("myP");  //получили сам элемент

myP.innerHTML;    //получить HTML содержимое элемента, имеющего id="myP"

myP.innerHTML = "<em>Что-то новое</em>";   //изменить HTML содержимое элемента, имеющего id="myP"
</textarea>

              </details>


              <details class="show-piece innerText">
                <summary><code>innerText -- (устаревший)</code> копирует текст, отображаемый элементом в
                  браузере(учитывает стили)</summary>

                <p><code>innerText в отличии от textContent</code> как бы копирует текст, отображаемый этим элементом в
                  браузере. Он учитывает стили</p>

                <p><code>innerText</code> не добавляет в возвращаемый результат содержимое style и script.</p>

                <p>учитывает стили элементов, и возвращает только текст отображаемый этим элементом в браузере.</p>

                <h3>разница между innerText и textContent:</h3>

                <textarea cols="120" rows="18">
                скроем элемент и он не отобразится в результате
                потому что innerText учитывает стили элементов

span {
  display: none;
}


<div>Внимание! <span>Это <strong>очень важный текст.</strong></span><script>alert('А это очень важное сообщение!');</script></div>


  const $elem = document.querySelector('div');
  const textByTextContent = $elem.textContent; // "Внимание! Это очень важный текст.alert('А это очень важное сообщение!');"
  const textByInnerText = $elem.innerText; // "Внимание!"

алерт не отобразится потому что innerText не 
добавляет в возвращаемый результат содержимое style и script.
</textarea>
              </details>


              <details class="show-piece outerText">
                <summary><code>outerText -- </code> удаляет полностью весь элемент а на его место ставит текстовое
                  содержимое</summary>
                <textarea cols="33" rows="3">
const text = $elem.outerText;

$elem.outerText = 'Текстовый контент...';
</textarea>


                <textarea cols="90" rows="25">
<div class="container">
  <div>...</div>
  <img src="image-01.png" alt="...">
  <div>...</div>
  <img src="image-02.png" alt="...">
</div>

&lt;script>
  const $elem = document.querySelectorAll('img');     // получим все элементы с тегом img
  $elem.forEach(($item) => {                                         // переберём все найденные элементы
    $item.outerText = 'Здесь было изображение';     // заменим элемент на текст
  });
&lt;/script>


        output:
    
<div class="container">
  <div>...</div>
   Здесь было изображение
  <div>...</div>
   Здесь было изображение
</div>
</textarea>

              </details>


              <details class="show-piece innerHTML">
                <summary><code>outerHTML -- </code> замена элемента и его дочерних компонентов</summary>

                <p>устанавливает или возвращает HTML контент, представляющий сам элемент и его дочерние элементы.</p>


                <textarea cols="120" rows="7">
var myList = document.getElementById("myList");

    //получить HTML список
myList.outerHTML;   

    //заменить HTML список на новый
myList.outerHTML = "&lt;ul>&lt;li>HTML&lt;/li>&lt;li>CSS&lt;/li>&lt;li>JavaScript&lt;/li>&lt;/ul>";  
</textarea>

              </details>


            </section>

            <section class="styleAndClass"><!-- Стили и классы -->

              <details class="show-block">
                <summary><code><a name="Стили и классы"> стили </a></code></summary>

                <p><code>.cssText </code> -- перезаписать или добавить стили</p>
                <pre><code>
elem.style.cssText = ` color: ...; font-size: ...; ` // перезапишет существующие
elem.style.cssText <span style="color: red;">+</span>= ` color: ...; font-size: ...; ` // НЕ перезапишет существующие

 cssText - пишет стили в атрибуте style
	

elem.style.WebkitBorderRadius = '5px';

document.body.style.backgroundColor = prompt('background color?', 'green');
    </code>
</pre>

                <details class="show-piece">
                  <summary><code>удалить присвоенное свойство</code></summary>
                  <pre><code>
вместо этого:
delete elem.style.display 

присвоить пустую строку
elem.style.display = "";

</code></pre>
                </details>


                <details class="show-piece getComputedStyle">
                  <summary><code>getComputedStyle(element, [pseudo]) - </code>получить стили</summary>

                  <ul>
                    <li><code>element - </code>Элемент, значения для которого нужно получить</li>
                    <li><code>pseudo - </code>Указывается, если нужен стиль псевдоэлемента. Пустая
                      строка
                      или отсутствие аргумента означают сам элемент.</li>
                  </ul>

                  <p>getComputedStyle требует полное свойство!
                    указывать точное свойство(paddingLeft,
                    marginTop,
                    borderTopWidth). При обращении к сокращённому: padding, margin, border – правильный результат не
                    гарантируется.</p>
                </details>


              </details>
            </section>

            <section class="styleAndClass">

              <details class="show-block">
                <summary><code>классы</code></summary>

                <pre><code>
elem.className = "alert";

</code></pre>

                <p>Классы – всегда предпочтительный вариант по сравнению со style. Мы должны манипулировать свойством
                  style только в том случае, если классы «не могут справиться»</p>

                <pre><code>
.className  -- заменяет всю строку с классами 
.classList  -- add / remove / toggle / contains - проверка(вернет: true / false) 

classList перебираемый, поэтому можно перебрать все классы:

&lt;body class="main page"&gt;

    for (let name of document.body.classList) {
      alert(name); // main, затем page
    }
&lt;/body&gt;
    </code>
</pre>


<details class="show-piece"><!-- remove add class -->
  <summary><code>remove add class</code></summary>
<textarea cols="60" rows="8">
const list = document.querySelectorAll('.menu li a');
list.forEach(item => {
  item.addEventListener('click', (e) => {
    list.forEach(el => { el.classList.remove('active'); });
    item.classList.add('active');
  });
});
</textarea>
</details>



              </details>
            </section>


            <section class="logical-operators"><!-- logical-operators -->

              <details class="show-block" open>
                <summary><code><a name="Логические операторы">Логические операторы</a></code></summary>


                <details class="show-piece">
                  <summary><code>?</code> -- если условие истинно, возвращается значение1, в противном случае –
                    значение2</summary>
                  <p>имеет три аргумента</p>
                  <pre>
  <code>
let result = условие ? значение1 : значение2;
  </code>
</pre>
                  <p>Сначала вычисляется условие: если оно истинно, тогда возвращается значение1, в противном случае –
                    значение2.</p>

                  <pre>
  <code>
let accessAllowed = (age &gt; 18) ? true : false;
  </code>
</pre>
                  <p>Технически, мы можем опустить круглые скобки вокруг age &gt; 18. Оператор вопросительного знака
                    имеет
                    низкий
                    приоритет,
                    поэтому он выполняется после сравнения &gt;.</p>
                  <pre>
  <code>
let accessAllowed = age &gt; 18 ? true : false;
  </code>
</pre>

                  <p>обычная последовательная проверка</p>
                  <pre>
  <code>
let age = prompt('Возраст?', 18);

let message = (age &lt; 3) ? 'Здравствуй, малыш!' : 
              (age &lt; 18) ? 'Привет!' : 
              (age &lt; 100) ? 'Здравствуйте!' : 'Какой необычный возраст!' ; 

alert( message );     
  </code>
</pre>


                  <pre>
  <code>
Вот как это выглядит при использовании if..else:

if (age &lt; 3) { 
  message='Здравствуй, малыш!' ; 
} else if (age &lt; 18) { 
  message='Привет!' ; 
} else if (age &lt; 100) {
  message='Здравствуйте!' ; 
} else { 
  message='Какой необычный возраст!' ; 
}
  </code>
</pre>

                </details>

                <details class="show-piece">
                  <summary><code>|| - или</code> -- возвращает первое истинное значение или последнее</summary>
                  <pre>
  <code>
result = a || b; //если первый операнд вернет true то второй не вычисляется
  </code>
</pre>
                  <p>Существует всего четыре возможные логические комбинации:</p>
                  <pre>
  <code>
alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false
  </code>
</pre>
                  <p>Если значение не логического типа, то оно к нему приводится в целях вычислений.</p>
                  <pre>
  <code>
    цепочка ИЛИ || возвращает первое истинное значение или последнее, если такое значение не найдено.

let currentUser = null;
let defaultUser = "John";

let name = currentUser || defaultUser || "unnamed";

alert( name ); // выбирается "John" – первое истинное значение

Если бы и currentUser, и defaultUser были ложными, в качестве результата мы бы наблюдали "unnamed".
  </code>
</pre>

                  <p>ИЛИ || вычисляет слева направо. Вычисление останавливается при достижении первого истинного
                    значения.
                    Этот
                    процесс
                    называется «сокращённым вычислением», поскольку второй операнд вычисляется только в том случае,
                    если
                    первого
                    недостаточно для вычисления всего выражения.</p>
                  <pre>
  <code>
let x;

true || (x = 1);

alert(x); // undefined, потому что (x = 1) не вычисляется

Если бы первый аргумент имел значение false, то || приступил бы к вычислению второго и выполнил операцию присваивания:

let x;

false || (x = 1);

alert(x); // 1


этот вариант использования || является "аналогом if". Первый операнд преобразуется в логический. Если он оказывается
ложным, начинается вычисление второго.
  </code>
</pre>
                </details>

                <details class="show-piece">
                  <summary><code>&& - и</code> -- находит первое ложное значение</summary>

                  <p>возвращает true, если оба аргумента истинны, а иначе – false</p>
                  <pre>
  <code>
result = a && b; 

alert( true && true ); // true
alert( false && true ); // false
alert( true && false ); // false
alert( false && false ); // false
  </code>
</pre>

                  <p>Если все операнды были истинными, возвращается последний.</p>
                  <p>Другими словами, И возвращает первое ложное значение. Или последнее, если ничего не найдено.</p>
                  <pre>
  <code>
    Если первый операнд ложный, && возвращает его. 
          Второй операнд игнорируется
alert( null && 5 ); // null
alert( 0 && "no matter what" ); // 0

alert( 1 && 2 && null && 3 ); // null

alert( 1 && 2 && 3 ); // 3
  </code>
</pre>

                </details>

              </details>

            </section>


            <section class="js__cycles">
              <details class="show-block">
                <summary><code><a name="циклы">
                циклы
              </a></code></summary>
                <p><b>for of --- snring, array, nodelist, map, set и т.д.</b></p>
                <p><b>for in --- object</b></p>
                <p><b>for --- свойства / значения</b></p>
                <p>for...in обход перечисляемых свойств объекта осуществляется в произвольном порядке.</p>
                <p>for...of обход происходит в соответствии с тем, какой порядок определён в итерируемом объекте</p>

                <p>for и for in вам нужно использовать конструкцию arr [index]:</p>
                <p>forEach() и for of, вы сразу получаете доступ к самому элементу массива. С forEach() вы можете так
                  же
                  получить
                  индекс массива, с for of индекс не доступен.</p>
                <p>проходит объект в произвольном порядке(порядок сверху в низ не горантирован)</p>


                <details class="show-piece for">
                  <summary><code>for (es5)-- </code>пройти n раз свойства или значения</summary>

                  <pre><code>
for (let i = 0; i &lt; arr.length; i++) {             let i = 0;
  console.log(i); //ключи                i никакого отношения к индексам не имеет
  console.log(arr[i]); //значения         это обычная переменная котрая изменяется 
}                                             каждую итерацию i++
 </code></pre>

                  <p>перебрать что то в обратном порядке:</p>

                  <pre><code>
for (let i = items.length - 1; i > = 0; i -= 1) { ... }

</code></pre>

                </details>

                <details class="show-piece">
                  <summary><code>for in -- </code>для перебора свойств объекта</summary>

                  <p>пройти в цикле по перечисляемым свойствам объекта и свойствам из прототипа.</p>
                  <p>Перечисляемые свойства – это свойства, которые разработчик добавляет объекту.</p>
                  <p>Встроенные свойства, например length у массива, не обходятся в цикле если им не указан метод. Для
                    изменения
                    значений дескрипторов применяется статический метод Object.defineProperty()</p>

                  <pre><code>
const person = {
  name: "Igor",
  age: 28,                            в цикле for in 
  city: "Bratsk",                     на место <span class="color-red">i</span>
  hobby: "programmer",                подставляется индекс
};                                    каждую итерацию цикла


for (let <span class="color-red">i</span> <span class="color-light-blue">in</span> person) {
  console.log(<span class="color-red">i</span> + "-" + person[<span class="color-red">i</span>])    person[<span class="color-red">i</span>]
}                                 
      name - Igor                     person.name
      age - 28                        person.age
      city - Bratsk                   person.city
      hobby - programmer              person.hobby  
                                                                               
</code></pre>




                  <h3 class="color-red">for in не стоит использовать для перебора массива:</h3>
                  <p>Нет гарантии, что for...in будет возвращать индексы в конкретном порядке. </p>
                  <p>Числовые свойства будут перечисляться в отсортированном порядке по возрастанию</p>


                  <pre><code>
let arr = [ "a", "b", "c", "d" ];    
                                        <span class="color-red">не перебирайте массивы с for in</span>
for (let <span class="color-red">i</span> <span class="color-light-blue">in</span> arr) {      
  console.log(<span class="color-red">i</span> + " - " + arr[<span class="color-red">i</span>]);      
};                                            
          <span class="color-red">i</span>     arr[<span class="color-red">i</span>]
     // ключ - значение
           0 - a
           1 - b
           2 - c
           3 - d

</code></pre>

                </details>


                <details class="show-piece">
                  <summary><code>for of (es6)-- </code>обход итерируемых объектов</summary>

                  <p><b>snring, array, nodelist, map, set и т.д.</b></p>
                  <p>почти то же что и forEach.</p>
                  <p>в отличие от forEach(), он работает с break, continue и return.</p>

                  <p>в отличии от for in порядок перебора объекта гарантирован</p>
                  <pre>
  <code>
let arr = [ "a", "b", "c", "d" ];        for of работает сразу со значениями
                                             к индексам доступа нет
for (let i <span class="color-red">of</span> arr) { -- i значение массива arr
  console.log(i)                                                          
};                                                        
      // значения 
            a
            b
            c 
            d
  </code>
</pre>

                  <h4>перебор object</h4>
                  <pre><code>
по дефолту не удобно перебирать object с for of
потому что object не итерируемый по умолчанию

const person = {             
  name: "Igor",                 
  age: 28, 
  city: "Bratsk", 
  hobby: "programmer", 
};

              массив ключей объекта                        массив значений объекта
for (let i <span class="color-red">of</span> <span class="color-light-blue">Object.<span class="color-red">keys</span>(person)</span>) {   |     for (let i <span class="color-red">of</span> <span class="color-light-blue">Object.<span class="color-red">values</span>(person)</span>) {
  console.log(i);                      |       console.log(i);
}                                      |     }  
        // name                        |          // Igor
           age                         |             28
           city                        |             Bratsk
           hobby                       |             programmer

 </code>
</pre>

                </details>


              </details>
            </section>


            


      


            <section class="checks">
              <details class="show-block">
                <summary><code><a name="проверки">Проверки</a></code></summary>

                <details class="show-piece typeof">
                  <summary>typeof -- узнать тип примитивного значения</summary>
                  <pre>
  <code>
 console.log(typeof 21); // =&gt; number
 console.log(typeof '21'); // =&gt; string
 console.log(typeof false); // =&gt; boolean
 console.log(typeof {}); // =&gt; object
 console.log(typeof undefined); // =&gt; undefined
 console.log(typeof null); // =&gt; object (признанный баг, который
         не исправляют ради обратной совместимости)
  </code>
</pre>
                </details>

                <details class="show-piece isNaN">
                  <summary>isNaN -- является ли значение выражения числом</summary>
                  <pre>
  <code>
isNaN(123) // false (число)
  
isNaN("50 рублей") // (не число) 
  </code>
</pre>
                  <p>Иногда можно получить такую ошибку JavaScript — NaN — когда значение не является числом (а
                    ожидается
                    число):</p>
                  <pre>
  <code>
  let a=8;
  let b="pi";
  let S=a*b; // S=NaN
  </code>
</pre>
                  <p>В качестве значения переменной может быть undefined — не определено. Такое случается, когда
                    переменная
                    создана, но значение ей не присвоено:</p>
                  <pre>
  <code>
   let b;
   document.write(b); // b=undefined 
  </code>
</pre>
                </details>


                <details class="show-piece">
                  <summary>четное или нечетное</summary>
                  <pre>
  <code>
const isEven = x =&gt; {
  
  if (x % 2 === 0) {  // If the remainder after dividing by two is 0, return true
    return true;
  }
  return false; // If the number is odd, return false
}

isEven(12);  //true
  </code>
</pre>
                </details>



                <details class="show-piece matches">
                  <summary><code>matches -- </code>проверить HTML-элемент на соответствие CSS-селектору.</summary>
                  <p>true / false</p>
                  <div class="show-code">
                    <h2 class="show-code__title"></h2>
                    <div class="show-code__description">
                      <p></p>
                    </div>
                    <div class="show-code__inner">
                      <div class="show-code__performance">
                        <section class="matches__inner">
                          <p>paragraph</p>
                          <i>i i i i i</i>
                          <span class="span">span -- по классу</span>
                          <strong>strong</strong>
                          <q>q q q q q</q>
                          <div>div -- по селектору</div>
                          <b>b b b b b</b>
                        </section>
                      </div>
                      <textarea class="show-code__textarea">
let matchesParent = document.querySelector(".matches__inner");

let matchesChildren = matchesParent.children;
let matchesChildrenArr = Array.from(matchesChildren);

console.log(matchesChildren)
for(let i of matchesChildrenArr) {
	if(i.matches(".span")) {
		i.style.color = "red";
	} 
	if (i.matches("div")) {
		i.style.color = "red";
	}
}
    </textarea>
                    </div>

                  </div>



                  <textarea cols="60" rows="10">
const elem = document.querySelectorAll('#questions > li');   // выберем все &lt;li> в #questions

elem.forEach((el) => { // переберём выбранные элементы
  if (el.matches('.answered')) {   // если элемент соответствует селектору .answered, то ...
    el.remove();   // удалим элемент
  }
}); 
</textarea>

                  <textarea name="" id="" cols="60" rows="10">
<div data-target="slider"></div>
    
const el = document.querySelector('[data-target="slider"]');
const result = el.matches('div');  // true
</textarea>

                  <textarea name="" id="" cols="50" rows="10">
document.querySelectorAll('li').forEach((el) => {
    if (el.matches('.active')) {
      console.log(el);   // li.active
    }
  }); 
</textarea>

                </details>

                <details class="show-piece closest">
                  <summary><code>closest -- </code>найти ближайшего предка</summary>

                  <p>element / null</p>
                  <p>поиск начинается с самого элемента, для которого данный метод вызывается. Если этот элемент будет
                    ему соответствоват</p>

                  <textarea name="closest" cols="55" rows="15">
<div class="level-1">
  <div class="level-2">
    <div class="level-3"></div>
  </div>
</div>


const el = document.querySelector('.level-3');
const elAncestor = el.closest('.level-1');

    console.log(elAncestor);   // &lt;div class="level-1">

будет подниматься по цепочке в верх пока не дойдет до 
указанного селектора --  closest('.level-1');
</textarea>




                  <div class="show-code">
                    <h2 class="show-code__title"></h2>
                    <div class="show-code__description">
                      <p></p>
                    </div>

                    <div class="show-code__inner">
                      <div class="show-code__performance">
                        <section class="closest">
                          <ul id="list">
                            <li>One</li>
                            <li>
                              Two
                              <ul>
                                <li>Four</li>
                                <li class="active">Five</li>
                              </ul>
                            </li>
                            <li>Three</li>
                          </ul>
                        </section>
                      </div>

                      <textarea class="show-code__textarea">
<div class="level-1">
  <div class="level-2">
    <div class="level-3"></div>
  </div>
</div>

        closest для .active его ближайшего родителя
    
<ul id="list">
  <li>One</li>
  <li>
    Two
    <ul>
      <li>Four</li>
      <li class="active">Five</li>
    </ul>
  </li>
  <li>Three</li>
</ul>

const closestActive = document.querySelector('.closest .active');
const closest = closestActive.closest('.closest  #list > li');

closest.style.backgroundColor = 'yellow';
    </textarea>
                    </div>
                  </div>

                </details>


                <details class="show-piece contains">
                  <summary><code>contains -- </code>содержит ли узел другой в качестве потомка</summary>
                  <p>true / false</p>

                  <p>проверка начинается с самого этого узла, для которого этот метод вызывается. </p>

                  <div class="contains__inner">

                    <textarea name="" id="" cols="70" rows="19">
<div id="contains-1">1
  <div id="contains-2">2
    <div id="contains-3">3</div>
  </div>
</div>

<div id="contains-4">4</div>

const containsOne = document.querySelector('#contains-1');
const containsThree = document.querySelector("#contains-3");
const containsFour = document.querySelector('#contains-4');


// contains-4 не потомок для contains-1 по этому false

containsOne.contains(containsOne);   // true
containsOne.contains(containsFour);  // false
containsOne.contains(containsThree); // true
</textarea>

                  </div>



                  <textarea name="" id="" cols="50" rows="25">
<h1>h1</h1>
<p>this is <b>tag b</b>.</p>

const el-P = document.querySelector('p');
const el-B = document.querySelector('b');
const textNode = el-B.firstChild;
const el-H1 = document.querySelector('h1');

    el-P.contains(el-P); // true
    el-P.contains(el-B); // true
    el-P.contains(textNode); // true
    
    el-P.contains(el-H1); // false -- h1 не потомок для p

        
Метод contains позволяет проверить является ли потомком не только узел-элемент, но и любой другой узел. Например, узнаем является ли потомком elDiv1 указанный текстовый узел:

const elDiv1 = document.querySelector('#div-1');
const textNode = document.querySelector('#div-3').firstChild;

    elDiv1.contains(textNode); // true
</textarea>

                </details>


              </details>
            </section>


            <section class="transformation">

              <details class="show-block">
                <summary><code><a name="Преобразования">Преобразования</a></code></summary>

                <pre>
    <code>
let a = parseInt(prompt("Возраст?", '18'));
let b = Number(prompt("Вesult")); 

x = +x // к числу
x = x + '' // к строке
x = !!x // к булеву типу

x = Number(x) 
x = String(x)
x = Boolean(x)
    </code>
</pre>

                <details class="show-piece join">
                  <summary>join - массив в строку</summary>
                  <pre>
  <code>
let arr = [1, 2, "str", false];

arr.join(" "); // "1 2 str false" (string)
  </code>
</pre>
                </details>

                <details class="show-piece split">
                  <summary>split - строка в массив</summary>
                  <pre>
  <code>
let arrTwo = str.split("/"); // ["1", "2", "str", "false"] (array)
  </code>
</pre>
                </details>

                <details class="show-piece toString">
                  <summary>toString - объект в строку</summary>
                  <pre>
    <code>
obj.toString 
    </code>
</pre>
                </details>

                <details class="show-piece keys-values">
                  <summary>keys / values - объект в массив</summary>
                  <p>В стандартном конструкторе Object имеются методы keys и values с помощью которых можно
                    трансформировать
                    объект в массив ключей и значений</p>
                  <pre>
  <code>
const car = {
  brand: 'Ford',
  color: 'blue'
}

const keys = Object.keys(car); // ['brand', 'color'] 
const values = Object.values(car); // ['Ford', 'blue'] 

  </code>
</pre>
                </details>

                <details class="show-piece nodelist-array">
                  <summary>NodeList - в массив </summary>
                  <pre>
  <code>
const nodeList = document.querySelectorAll('div');
const result = [];

for (const node of nodeList) {
  result.push(node);
}
  </code>
</pre>
                  <p>Также у NodeList есть метод forEach</p>
                  <pre>
  <code>
const nodeList = document.querySelectorAll('div');
const result = [];

nodeList.forEach((node) =&gt; {
  result.push(node);
});
  </code>
</pre>
                  <p>Array.from();</p>
                  <pre>
  <code>
const nodeList = document.querySelectorAll('div');
const result = Array.from(nodeList);
  </code>
</pre>
                  <p>spread</p>
                  <pre>
  <code>
const divList = document.querySelectorAll('div');
const arr = [...divList];
  </code>
</pre>
                </details>

                <details class="show-piece parseInt">
                  <summary>parseInt - строку в целое число</summary>
                  <p>преобразует указанную строку в целое число. Если есть второй параметр — система счисления —
                    преобразование происходит по указанному основанию системы счисления (8, 10 или 16):</p>
                  <pre>
    <code>
parseInt("435") // 435
parseInt("3.14") // 3
parseInt("-7.875") // -7
parseInt("Вася") // NaN
parseInt("15" ,8) // 13

parseInt - отсекает дробную часть числа.
    </code>
</pre>
                </details>

                <details class="show-piece parseFloat">
                  <summary>parseFloat - строку в дробное число</summary>
                  <p>преобразует указанную строку в число с плавающей точкой (десятичной):</p>
                  <pre>
    <code>
parseFloat ("435") // 435
parseFloat("3.14") // 3.14
parseFloat("-7.875") // -7.875
parseFloat ("Вася") // NaN
parseFloat ("17.5") // 17.5
    </code>
</pre>
                </details>

              </details>
            </section>


            <section class="events">

              <details class="show-block">
                <summary><code><a name="events">events</a></code></summary>

                <a href="https://www.youtube.com/watch?v=bWCzbR5DvCo&t=908s" target="_blank"
                  rel="noopener noreferrer">источник</a>


                <h3>виды событий</h3>

                <h4>простые:</h4>
                <ul>
                  <li><code>mousedown / mouseup -- </code>нажата / отпущена</li>
                  <li>
                    <code>mouseover / mouseout -- </code>курсор появляется над элементом / уходит с него
                  </li>
                  <li>
                    <code>mousemove -- </code>каждое движение над элементом генерирует событие
                  </li>
                  <li>
                    <code>contentmenu -- </code>нажатие правой клавишей миши(и клавиатурой вызывается)
                  </li>
                </ul>

                <h4>контекстные:</h4>
                <ul>
                  <li><code>click -- </code>Вызывается при mousedown, а затем mouseup над одним и тем же элементом
                  </li>
                  <li><code>dblclick -- </code>двойной <code>click</code> над одним и тем же элементом</li>
                </ul>




                <p>каждое событие имеет свой объект свойств с которыми можно взаимодействовать.</p>
                <pre><code>
clientX : 273
clientY : 508
offsetX : 100
offsetY : 77

code : "KeyS"
composed : true
ctrlKey : false
currentTarget : null
defaultPrevented : false
key : "s"
</code></pre>
                <p>их можно вытащить при помощи event</p>
                <p>какое событие будет указано такой объект и выдаст консоль со всеми свойствами этого события</p>

                <pre><code>
document.onclick = (event) => {
  event         //все детали события (и список всех событий)
  event.type    //тип события
  event.target  //объект на котором сработало событие
  event.currentTarget //объект которому назначен обработчик
  
  console.log(event.offsetX);
  console.log(event.offsetY);
}
  </code>
</pre>



                <details class="show-piece which">
                  <summary><code>.which - </code>вернет номер кнопки</summary>
                  <pre>
  <code>
document.addEventListener("mousedown", function(event) {
  console.log(`нажата кнопка ${event.which}`);
})

document.addEventListener("mouseup", function (event) {
  console.log(`отпущена кнопка ${event.which}`);
})

document.addEventListener("click", function (event) {
  console.log(`нажата основная кнопка ${event.which}`);
})
  </code>
</pre>
                </details>


                <details class="show-piece ">
                  <summary><code>oninput - </code><a name="oninput">получить данные из поля ввода без отправки формы</a>
                  </summary>

                  <p>Мы уже умеем получать <a href="https://htmlacademy.ru/courses/343/run/15">данные из поля
                      ввода</a>, но
                    только
                    после того, как форма была отправлена. Сейчас же нам нужно оценить
                    длину комментария ещё до отправки. Как быть? Инструкции внутри обработчика oninput выполняются
                    каждый раз, когда
                    значение в
                    поле ввода
                    меняется.</p>
                  <pre>
  <code>
          Найдём поле ввода
let textarea = document.querySelector('textarea');

          Добавим обработчик событий
textarea.oninput = function () {
          Выведем данные из поля ввода
  console.log(textarea.value);
};
  </code>
</pre>

                  <p>Благодаря обработчику событий oninput мы можем получить текст комментария ещё до того, как
                    пользователь
                    его
                    отправит.</p>


                  <form action="#">

                    <textarea class="first-textarea" name="first-textarea" cols="30" rows="5"
                      id="first-textarea"></textarea>

                    <span class="output-count">использовано
                      <output class="first-output" for="first-textarea">0</output>/10 символов
                    </span>

                    <button class="first-button" type="button">button</button>

                  </form>

                </details>


                <details class="show-piece scroll">
                  <summary><code>scroll</code></summary>
                  <p>прокрутку нельзя отменить используя event.preventDefault(отменяет действие по умолчанию); потому
                    что метод сработает уже после того как скролл произойдет</p>
                  <pre><code>
document.addEventListener("scroll", function (event) {
  console.log(event);
  console.log(`${scrollY}px`);
})
</code></pre>
                </details>


                <details class="show-piece mousemove">
                  <summary><code>mousemove - </code> каждое движении мыши над элементом</summary>
                  <div class="mousemove__hover example">
                    <h4>mousemove</h4>
                    <p>output</p>
                  </div>
                </details>


                <details class="show-piece mouse-over-out">
                  <summary><code>mouseover / mouseout - </code>реагируют на дочерние компоненты элемента</summary>
                  <p>реагируют они на них потому что они оба всплывают</p>
                  <p>Оба имеют <code>.relatedTarget</code></p>

                  <h5>mouseover</h5>

                  <p><code>event.target - </code>элемент на который курсор пришел</p>
                  <p><code>event.relatedTarget - </code>элемент с которого курсор пришел</p>

                  <h5>mouseout</h5>

                  <p>для него все наоборот</p>
                  <p><code>event.target - </code>элемент с которого курсор пришел</p>
                  <p><code>event.relatedTarget - </code>элемент на который курсор пришел</p>

                  <div class="mouse-over-out__hover example">
                    <h4>mouseout</h4>
                    <h4>mouseover</h4>
                    <p>реагируют на дочерние компоненты элемента</p>
                  </div>

                  <h3>пример реагирования на потомков</h3>

                  <p>переход курсором на потомков чувствуется</p>

                  <h4>сделан на делегировании событий</h4>

                  <div class="mouse-over-out__hover-grid">
                    <span>1</span>
                    <span>2</span>
                    <span>3</span>
                    <span>4</span>
                    <span>5</span>
                    <span>6</span>
                    <span>7</span>
                    <span>8</span>
                    <span>9</span>
                  </div>



                </details>


                <details class="show-piece mouse-enter-leave">
                  <summary><code>mouseenter / mouseleave - </code>НЕ реагируют на дочерние компоненты элемента</summary>

                  <p>не реагируют потому что они не всплывают</p>

                  <div class="mouse-enter-leave__hover example">
                    <h4>mouseenter</h4>
                    <h4>mouseleave</h4>
                    <p>не реагируют на дочерние компоненты элементы</p>
                  </div>
                </details>


                <details class="show-piece drag-field-show">
                  <summary><code>mousedown - </code>перетаскивание</summary>
                  <div class="drag-field">
                    <div class="drag-field__item"></div>
                    <div class="drag-field__point"></div>
                  </div>
                </details>


                <details class="show-piece key-down-up">
                  <summary><code>keydown / keyup - </code>события клавиш</summary>
                  <p>пример в консоли</p>

                  <pre><code>
event.repeat // автоповтор нажатой клавиши
автоповтор укажет в консоли true если вы
зажали клавишу, при одиночном клике укажет false

event.code  // вернет закодированную кнопку

event.key   // вернет значение 

</code></pre>

                  <div class="key-down-up__item">

                    <textarea class="key-down-up__textarea" maxlength="30" placeholder="введите что нибудь"></textarea>
                    <div class="key-down-up__counter">Осталось <span>30</span> символов</div>

                  </div>

                </details>


                <details class="show-piece loading">
                  <summary><code>loading -- </code>событие загрузки страницы</summary>

                  <p><code>DOMContentLoaded - </code> Браузер полностью загрузил html, было построено DOM дерево, но
                    внешние ресурсы, такие как imh или стили, могут быть еще не загружены</p>
                  <p><code>load - </code>браузер загрузил html и внешние ресурсы (картинки, стили и т.д.)</p>
                  <p><code>beforeunload / unload - </code>пользователь покидает страницу</p>
                  <p><code>document.readyState - </code>состояние загрузки(можем отследить состояние
                    загрузки с
                    помощью этого свойства)</p>
                  <p>у <code>document.readyState</code> есть 3 возможных значения:</p>

                  <ul>
                    <li><code>loading - </code>документ загружается</li>
                    <li><code>interactive - </code>документ был полностью прочитан</li>
                    <li><code>complete - </code>документ был полностью прочитан и все ресурсы были тоже
                      загружены(картинки, стили и т.д.)</li>
                  </ul>

                  <img class="loading__img" src="../img/1.png" alt="">
                  <pre><code>
// DOMContentLoaded - срабатывает на объекте document
document.addEventListener("DOMContentLoaded", readyDom);
                          
// readyLoad - срабатывает на объекте window
window.addEventListener("load", readyLoad);
                          
function readyDom() {
  const image = document.querySelector(".loading__img");
  console.log(document.readyState);  //interactive
  console.log("DOM загружен!");
  console.log(image.offsetWidth);
}
                          
function readyLoad() {
  const image = document.querySelector(".loading__img");
  console.log(document.readyState); //complete
  console.log("Страница загружен!");
  console.log(image.offsetWidth);
}
</code></pre>

                </details>




                <h2>событие ухода со страницы</h2>


                <details class="show-piece beforeunload">
                  <summary><code>beforeunload - </code>работает на объекте window</summary>
                  <pre><code>
window.addEventListener("beforeunload", beforeUnload);
                          
function beforeUnload(event) {
  event.preventDefault(); // отменение поведения как указано в стандарте
  event.returnValue = ''; // хром требует установки возвратного значения
}
</code></pre>

                </details>

                <details class="show-piece unload">
                  <summary><code>unload - </code>пользователь уже ушел со страницы но мы можем заставить браузер что то
                    выполнить в фоновом режиме</summary>
                  <p>работает на объекте window</p>

                  <pre><code>
window.addEventListener("unload", function (e) {
   Отправка статистики в фоновом режиме и т.д.
   navigator.sendBeacon(url, data)
   https://w3c.github.io/beacon/.
})
                          </code></pre>
                </details>

                <section><!-- Всплытие и погружение -->

                  <details class="show-block">
                    <summary><code>Всплытие и погружение</code></summary>

                    <p>В основном обработчики работают на всплытие а не на погружение</p>
                    <p>Когда на элементе происходит событие, обработчик сначала срабатывает на нём следом на его
                      родителе затем выше и т.д., вверх по цепочке предков.</p>


                    <div class="ascent">
                      <h4>кликайте на блоки и смотрите консоль</h4>
                      <p>всплытие событий</p>

                      <div class="ascent-one">
                        <span>блок 1</span>
                        <div class="ascent-two">
                          <span>блок 2</span>
                          <div class="ascent-three">
                            <span>блок 3</span>
                          </div>
                        </div>
                      </div>

                      <h3>Ловим событие еще на погружении</h3>

                      <p><code>"capture": true</code></p>
                      <p>тут второй блок отлавливает событие ще на погружении и обрабатывает его, следом
                        обрабатываются
                        события на всплытии</p>

                      <div class="ascentListener-one">
                        <span>блок 1</span>
                        <div class="ascentListener-two">
                          <span>{"capture": true}</span>
                          <div class="ascentListener-three">
                            <span>блок 3</span>
                          </div>
                        </div>
                      </div>

                    </div>

                    <p>остановить всплытие можно методом <code>event.stopPropagation();</code></p>
                    <p>Все события которые всплыли бы(которые идут после этого вверх по цепочке) игнорируются и не
                      обрабатываются</p>





                    <div class="events__item">

                      <h3>Доступ к элементу через this</h3>
                      <p>Внутри обработчика события this ссылается на текущий элемент, то есть на тот, на котором, как
                        говорят,
                        «висит» (т.е. назначен) обработчик.</p>

                      <button onclick="console.log(this.innerHTML)">Нажми меня</button>
                      <button onclick="console.log(this)">Нажми меня</button>
                    </div>



                  </details>
                </section>


                <details class="show-piece"><!-- addEventListener -->
                  <summary><code>addEventListener</code></summary>

                  <pre>


  <code>
const options = { 
  "capture": false,
  "once": false,
  "passive": true
}

element.addEventListener("click", testFunction, options);

function testFunction() {
  console.log(this); //выведет в консоль тип события
}
  </code>
</pre>

                  <dl>
                    <dt><code>"capture": true / false  -- </code>порядок обработки событий</dt>
                    <dd>
                      Фаза на которой должен сработать обработчик (всплытие или погружение). Ловит событие еще на
                      погружении
                      и можно обработать его прежде чем сработают обработчики на всплытие. если поставить на
                      средний элемент
                      true то сначала отработает он при погружении потом начнет всплывать и отработают другие
                      события, на
                      третьем и первом элементе
                    </dd>

                    <dt><code>"once": true / false -- </code>removeEventListener</dt>
                    <dd>
                      true удалит обработчик после выполнения (то же что и removeEventListener)
                    </dd>

                    <dt><code>"passive": true / false -- </code> не выполнит <code>preventDefaгlt();</code></dt>
                    <dd>
                      true указывает что обработчик не собирается
                      выполнять preventDefaгlt(отменяет действие браузера по умолчанию(смотрите в делегировании
                      собитий)).
                      Это значит что при скролле пальцем или подобное действие обработчик не будет отменять
                      действия
                      браузера по умолчанию, значит что при скролле пальцем задержек всяких не будет возникать и
                      скролл
                      будет плавным. true убирает ненужные задержки и браузер сразу начинает выполнять действия по
                      умолчанию
                      для некоторых браузеров эта опция уже включена по умолчанию(указана true) для таких событий
                      как:
                      <ul>
                        <li>
                          <code>addEventListener("touchstart",...)</code>
                        </li>
                        <li>
                          <code>addEventListener("touchmove",...)</code>
                        </li>
                      </ul>
                      т.е. если у вас есть отмена стандартных действий браузера по
                      умолчанию как в примере <a href="#events__item-link-cancle">отмены действий браузера</a> и
                      указан
                      <code>addEventListener(..., {"passive": true})</code> то действия по умолчанию выполнятся
                      проигнорировав вашу отмену
                    </dd>

                  </dl>

                </details>


                <details class="show-piece delegate-event">
                  <summary><code>Делегирование событий</code></summary>
                  <p>Если элементов достаточно много что бы не вешать обработчик на каждый из них(висящие на них
                    обработчики
                    могут не хило замедлить работу), можно повесить обработчик на их родителя, а функциональность
                    добавить
                    всем элементам через цикл.</p>

                  <button class="delegate-event__button">1</button>
                  <button class="delegate-event__button">2</button>
                  <button class="delegate-event__button">3</button>
                  <button class="delegate-event__button">4</button>

                  <li class="events__item">
                    <h4>меню на делегировании событий</h4>

                    <p>обработчик висит на document а не на самом меню</p>
                    <p>данное меню скрывается атрибутом hidden</p>

                    <nav class="delegate-event--menu">
                      <button type="button" class="delegate-event--menu--button">
                        <span>Открыть меню</span>
                        <span>Закрыть меню</span>
                      </button>
                      <ul hidden>
                        <li><a>пункт 1</a></li>
                        <li><a>пункт 2</a></li>
                        <li><a>пункт 3</a></li>
                        <li><a>пункт 4</a></li>
                      </ul>
                    </nav>
                  </li>

                </details>


                <section><!-- Действия браузера по умолчанию и их отмена -->
                  <details class="show-block">
                    <summary><code>Действия браузера по умолчанию и их отмена</code></summary>
                    <p>Многие события автоматически влекут за собой действие браузера по умолчанию, переходы по ссылкам
                      и т.д.
                    </p>
                    <ul class="link-cancle list-reset">

                      <li>
                        <a href="https://www.google.com" target="_blank" rel="noopener noreferrer">ссылка работает
                          как
                          указывает браузер(по умолчанию)</a>
                      </li>
                      <li>
                        <a class="link-cancle__two" href="https://www.google.com" target="_blank"
                          rel="noopener noreferrer">отменяем
                          работу по умолчанию
                          через addEventListener</a>
                      </li>
                      <li>
                        <a class="link-cancle__three" href="https://www.google.com" target="_blank"
                          rel="noopener noreferrer">отменяем
                          работу по умолчанию
                          через return</a>
                      </li>

                    </ul>

                    <pre><code>
let linkCancleTwo = document.querySelector(".link-cancle__two");
let linkCancleThree = document.querySelector(".link-cancle__three");

linkCancleTwo.addEventListener("click", function (event) {
  event.preventDefault(); //отменяет действие по умолчанию
});

//то же что и выше только если нельзя использовать addEventListene
linkCancleThree.onclick = function () {
  return false; 
}
</code></pre>

                  </details>
                </section>


                <details class="show-piece onchange"><!-- onchange -->
                  <summary><code>onchange</code></summary>

                  <p>Событие onchange происходит при изменении значения элемента HTML. onchange происходит, когда
                    элемент
                    теряет фокус после изменения содержимого.</p>
                  <p>onchange можно использовать с разными элементами. Он срабатывает, когда пользователь переключает
                    чекбокс
                    или
                    радиокнопки.</p>
                  <pre>
  <code>
&lt;element onchange="myScript"&gt;

object.onchange = function(){myScript};

object.addEventListener("change", myScript);

  </code>
</pre>

                  <pre>
  <code>

    <a target="_blank" href="https://htmlacademy.ru/courses/351/run/13">Полное задание htmlacademy</a>

  select — это элемент с классом filter. 
  Найдём его, сохраним в переменную и добавим обработчик событий onchange.
  После этого скажем JavaScript выводить значение фильтра в консоль и 
  по очереди выберем несколько категорий из списка.


let articles = document.querySelectorAll('.news-block');   создаем артикль
let filter = document.querySelector('.filter');     селект

filter.onchange = function () { // onchange сработает при изменении в select
  for (let article of articles) {           //проверка, что выбранное значение фильтра строго не равно 'all'
    if (article.dataset.category !== filter.value && filter.value !== 'all') {                          
      article.classList.add('hidden');
    } else {
      article.classList.remove('hidden');
    }
  }
};



.hidden {
  display: none;
}
  </code>
</pre>


                  <p>onchange срабатывает, если значение поля ввода изменилось и пользователь закончил ввод.
                    Например, если
                    пользователь передвинул ползунок и отпустил его. Или ввёл что-то в текстовое поле и убрал из
                    него
                    курсор.
                  </p>
                  <p>oninput срабатывает на каждое изменение значения, независимо от того, завершил пользователь ввод
                    или
                    нет.
                    Например, он сработает на каждое изменение положения ползунка, даже если пользователь продолжает
                    его
                    двигать. И на
                    каждый новый символ в текстовом поле, даже если пользователь продолжает вводить текст.
                  </p>




                  <pre>
  <code>

&lt;label&gt;Цвет текста:
  &lt;select&gt; class="filter color-setting" name="font-color"&gt;
    &lt;option&gt; value="inherit" selected&gt;По умолчанию&lt;/option&gt;
    &lt;option&gt; value="purple"&gt;Пурпурный&lt;/option&gt;
    ...
  &lt;/select&gt;
&lt;/label&gt;

&lt;label&gt;Размер текста (&lt;output&gt;px class="pixels"&gt;14&lt;/output&gt;px)
  &lt;input class="size-setting" type="range" min="8" max="48" step="1" value="14"&gt;
&lt;/label&gt;

&lt;label&gt;Размер текста (&lt;output&gt;px class="pixels"&gt;14&lt;/output&gt;px)
  &lt;input class="size-setting" type="range" min="8" max="48" step="1" value="14"&gt;
&lt;/label&gt;


let longread = document.querySelector('.longread'); //блок с текстом
let colorSetting = document.querySelector('.color-setting');   
let sizeSetting = document.querySelector('.size-setting');         
let pixels = document.querySelector('.pixels');
let backgroundSetting = document.querySelector('.background-setting');

colorSetting.onchange = function () { 
  longread.style.color = colorSetting.value;
};

sizeSetting.oninput = function () {  // oninput подходит больше
  pixels.textContent = sizeSetting.value;
  longread.style.fontSize = sizeSetting.value + 'px';
};

backgroundSetting.onchange = function() {
  longread.style.backgroundColor = backgroundSetting.value;
}
  </code>
</pre>

                </details>


                <details class="show-piece show-password">
                  <summary><code>показать пароль</code></summary>

                  <pre>
  <code>
&lt;input class="password" type="password" placeholder="**********" required&gt;
&lt;input class="show-password" type="checkbox"&gt;


let password = document.querySelector('.password');
let showPassword = document.querySelector('.show-password');
let securityBar = document.querySelector('.security-bar');

showPassword.onchange = function () {
  if (showPassword.checked) {
     password.type = 'text';
  } else {                          //если чекбокс не checked то 
    password.type = 'password';       изменим type на pasword
  }                                  что бы снова скрыть пароль
};

      прогрессбар заполнения пароля
password.oninput = function () {
  
  let passLength = password.value.length;
  
  securityBar.style.width = passLength * 10 + '%';
  
  if (passLength &lt;= 5) {
    securityBar.style.backgroundColor = 'red';
  } else if (passLength > 5 && passLength &lt; 10) {
    securityBar.style.backgroundColor = 'gold';
  } else {
    securityBar.style.backgroundColor = 'green';
    }
};

тут * на 10 потому что минимальная длина пароля 10 символов.
умножайте на свое минимальное значение что бы полоса под инпутом 
заполнялась актуально
  </code>
</pre>

                </details>


                <details class="show-piece"><!-- выбор цвета по клику -->
                  <summary><code>выбор цвета по клику</code></summary>

                  <div class="controls">
                    <div class="container">
                      <select class="chosen-color" name="chosen-color">
                        <option value="black">Чёрный</option>
                        <option value="white">Белый</option>
                        <option value="grey">Серый</option>
                        <option value="pink">Розовый</option>
                        <option value="red">Красный</option>
                        <option value="darkorange">Оранжевый</option>
                        <option value="saddlebrown">Коричневый</option>
                        <option value="yellow">Золотой</option>
                        <option value="greenyellow">Салатовый</option>
                        <option value="forestgreen">Зелёный</option>
                        <option value="aquamarine">Аквамарин</option>
                        <option value="lightskyblue">Голубой</option>
                        <option value="lightsteelblue">Серо-голубой</option>
                        <option value="darkblue">Тёмно-синий</option>
                        <option value="indigo">Индиго</option>
                        <option value="mediumpurple">Фиолетовый</option>
                        <option value="purple">Пурпурный</option>
                      </select>
                      <input class="eraser visually-hidden" id="eraser-mode" type="checkbox" name="eraser">
                      <label class="eraser-label" for="eraser-mode">Ластик</label>
                    </div>
                  </div>

                  <div class="main">

                </details>





                <div class="canvas">
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                  <div class="pixel"></div>
                </div>
        </div>



        </details>
        </section>



        </section>

        </ul>

        </section>


        <section class="export-import">
          <details class="show-block">
            <summary><code><a name="export-import">export-import</a></code></summary>

            <textarea cols="55" rows="5">
import * as name from"./.../....js"; 

*     - все файлы 
as    - общее имя(name) всех файлов для обращения к ним
from  - откуда
</textarea>

            <p><b>import</b> <em>дефолтные через запятую</em><b>,</b> { <em>именованные через запятую</em> }
              откуда
              "./... .js"
            </p>

            <div class="export-import__box">

              <pre><code>
<b>Основной файл</b>
  
          
import del, { sum, show, color } from "./func.js";
        


color(elem);
    
sum(4, 1);
    
show(elem);

del(elem);
    <hr>  
<b>переименование</b>

import del as  delete, { * as <span style="color: red;">name</span> } from "./func.js";
import del теперь delete, { все теперь <span style="color: red;">name</span> } из "./func.js";

функции стали как свойства объекта <span style="color: red;">name</span>
но не все а только те которые мы
объединили в объект <ins> * as name</ins>


<span style="color: red;">name</span>.color(elem);
  
<span style="color: red;">name</span>.sum(4, 1);

<span style="color: red;">name</span>.show(elem);

delete(elem); //не свойсво объекта <span style="color: red;">name</span>
</code></pre>

              <pre><code>
<b>Дополнительный файл</b>
  
  
let sum = function (a, b) { ... }
let show = function (elem) { ... }

export let color = function() { ... }
  
export default function del(elem) { ... }
  


      
объявленный экспорт снизу не перечисляется:  

export { sum, show };
</code></pre>
            </div>
          </details>
        </section>

        </section>

      </div>





  </div>
  </main>






  <footer class="page--footer">
    <div class="container">
      <div class="page--footer__inner">

        footer

      </div>
    </div>
  </footer>


  </div>

  <script src="../main.js"></script>
  <script src="../js/js.js"></script>
</body>

</html>